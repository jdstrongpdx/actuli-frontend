// ToDoList.tsx
import { useEffect, useState } from 'react';
import { MsalAuthenticationTemplate } from '@azure/msal-react';
import { InteractionType } from '@azure/msal-browser';

import { ListView } from '../components/toDo/ListView.tsx';
import { loginRequest, protectedResources } from "../authConfig.ts"
import useFetchWithMsal from '../hooks/useFetchWithMsal';

const ToDoListContent = () => {
    const { error, execute } = useFetchWithMsal({
        scopes: protectedResources.Backend.scopes.read,
    });

    const [toDoListData, setToDoListData] = useState(null);

    useEffect(() => {
        if (!toDoListData) {
            execute("GET", protectedResources.Backend.endpoint + "todolist").then((response) => {
                setToDoListData(response);
            });
        }
    }, [execute, toDoListData])

    if (error) {
        return <div>Error: {error.message}</div>;
    }

    return <>{toDoListData ? <ListView toDoListData={toDoListData} /> : null}</>;
};

/**
 * The `MsalAuthenticationTemplate` component will render its children if a user is authenticated
 * or attempt to sign a user in. Just provide it with the interaction type you would like to use
 * (redirect or popup) and optionally a request object to be passed to the login API, a component to display while
 * authentication is in progress or a component to display if an error occurs. For more, visit:
 * https://github.com/AzureAD/microsoft-authentication-library-for-js/blob/dev/lib/msal-react/docs/getting-started.md
 */
export const ToDoList = () => {
    const authRequest = {
        ...loginRequest,
    };

    return (
        <MsalAuthenticationTemplate
            interactionType={InteractionType.Redirect}
            authenticationRequest={authRequest}
        >
            <ToDoListContent />
        </MsalAuthenticationTemplate>
    );
};

// ListView.tsx
import React, { useState, useRef, useEffect } from 'react';
import ListGroup from "react-bootstrap/ListGroup";

import { ToDoForm } from "./ToDoForm.tsx";
import { ToDoItem } from "./ToDoItem.tsx";

import useFetchWithMsal from '../../hooks/useFetchWithMsal.tsx';
import { protectedResources } from "../../authConfig.ts"

function usePrevious(value) {
    const ref = useRef();

    useEffect(() => {
        ref.current = value;
    });

    return ref.current;
}

export const ListView = (props) => {

    const { error, execute } = useFetchWithMsal({
        scopes: protectedResources.Backend.scopes.write
    });

    const [tasks, setTasks] = useState(props.toDoListData);

    const handleAddTask = (description) => {
        const newTask = {
            description: description,
        };

        execute('POST', protectedResources.Backend.endpoint, newTask).then((response) => {
            if (response) {
                setTasks([...tasks, response]);
            }
        });
    };

    const handleDeleteTask = (id) => {
        execute("DELETE", protectedResources.Backend.endpoint + `/${id}`).then((response) => {
            if (response.status === 200 || response.status === 204) {
                const remainingTasks = tasks.filter(task => id !== task.id);
                setTasks(remainingTasks);
            }
        });
    }

    const handleEditTask = (id, description) => {
        const updatedTask = tasks.find((task) => id === task.id);
        updatedTask.description = description;

        execute('PUT', protectedResources.Backend.endpoint + `/${id}`, updatedTask).then((response) => {
            const updatedTasks = tasks.map((task) => {
                if (id === task.id) {
                    return { ...task, description: description };
                }
                return task;
            });
            setTasks(updatedTasks);
        });
    };

    const taskList = tasks.map((task) => {
        return <ToDoItem
            id={task.id}
            description={task.description}
            key={task.id}
            deleteTask={handleDeleteTask}
            editTask={handleEditTask}
        />
    });

    const listHeadingRef = useRef(null);
    const prevTaskLength = usePrevious(tasks.length);

    useEffect(() => {
        if (tasks.length - prevTaskLength === -1) {
            listHeadingRef.current.focus();
        }
    }, [tasks.length, prevTaskLength]);

    if (error) {
        return <div>Error: {error.message}</div>;
    }

    return (
        <div className="data-area-div">
            <ToDoForm addTask={handleAddTask} />
            <h2 id="list-heading" tabIndex="-1" ref={listHeadingRef}>{""}</h2>
            <ListGroup className="todo-list">
                {taskList}
            </ListGroup>
        </div>
    );
}

// ToDoForm.tsx

import React, { useState } from "react";
import { Button, Form, InputGroup } from "react-bootstrap";

export const ToDoForm = (props) => {
    const [description, setDescription] = useState('');
    const handleSubmit = (e) => {
        e.preventDefault();

        if (!description.trim()) {
            return;
        }

        props.addTask(description);
        setDescription('');
    }

    const handleChange = (e) => {
        setDescription(e.target.value);
    }

    return (
        <Form className="todo-form" onSubmit={handleSubmit}>
            <Form.Group>
                <InputGroup className="mb-7">
                    <Form.Control
                        type="text"
                        id="new-todo-input"
                        name="text"
                        autoComplete="off"
                        value={description}
                        onChange={handleChange}
                        placeholder="Enter a task"
                    />
                    <Button variant="primary" type="submit">
                        Add
                    </Button>
                </InputGroup>
            </Form.Group>
        </Form>
    );
}

// ToDoItem.tsx
import React, { useEffect, useRef, useState } from "react";
import Button from "react-bootstrap/Button";
import ButtonGroup from "react-bootstrap/ButtonGroup";
import Form from "react-bootstrap/Form";
import ListGroup from "react-bootstrap/ListGroup";

const usePrevious = (value) => {
    const ref = useRef();

    useEffect(() => {
        ref.current = value;
    });

    return ref.current;
}

export const ToDoItem = (props) => {
    const [isEditing, setEditing] = useState(false);
    const [newDescription, setDescription] = useState('');

    const editFieldRef = useRef(null);
    const editButtonRef = useRef(null);

    const wasEditing = usePrevious(isEditing);

    const handleChange = (e) => {
        setDescription(e.target.value);
    }

    const handleSubmit = (e) => {
        e.preventDefault();

        if (!newDescription.trim()) {
            return;
        }

        props.editTask(props.id, newDescription);
        setDescription('');
        setEditing(false);
    }

    const editingTemplate = (
        <div className="todo-edit">
            <Form onSubmit={handleSubmit}>
                <Form.Group>
                    <Form.Label htmlFor={props.id}>New name for {props.name}</Form.Label>
                    <Form.Control
                        id={props.id}
                        type="text"
                        value={newDescription}
                        onChange={handleChange}
                        ref={editFieldRef}
                    />
                </Form.Group>
                <div className="btn-group">
                    <ButtonGroup>
                        <Button variant="warning" type="button" onClick={() => setEditing(false)}>
                            Cancel
                        </Button>
                        <Button variant="success" type="submit">
                            Save
                        </Button>
                    </ButtonGroup>
                </div>
            </Form>
        </div>
    );

    const viewTemplate = (
        <div className="todo-view">
            <Form.Group>
                <label className="todo-label" htmlFor={props.id}>
                    {props.description}
                </label>
                <ButtonGroup className="todo-view-btn">
                    <Button variant="warning" onClick={() => setEditing(true)} ref={editButtonRef}>
                        Edit
                    </Button>
                    <Button variant="danger" onClick={() => props.deleteTask(props.id)}>
                        Delete
                    </Button>
                </ButtonGroup>
            </Form.Group>
        </div>
    );

    useEffect(() => {

        if (!wasEditing && isEditing) {
            editFieldRef.current.focus();
        }

        if (wasEditing && !isEditing) {
            editButtonRef.current.focus();
        }

    }, [wasEditing, isEditing]);

    return <ListGroup.Item className="todo-item">{isEditing ? editingTemplate : viewTemplate}</ListGroup.Item>;
}
